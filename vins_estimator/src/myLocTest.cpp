/*******************************************************
 * Author: Weizhe Liu
 * Date: 2019/3
 *******************************************************/

#include <stdio.h>
#include <queue>
#include <map>
#include <thread>
#include <mutex>
#include <ros/ros.h>
#include <nav_msgs/Odometry.h>
#include <sensor_msgs/PointCloud.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/point_cloud_conversion.h>
#include <sensor_msgs/CompressedImage.h>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/opencv.hpp>
#include "estimator/my_estimator.h"
#include "my_transform.h"
#include "estimator/parameters.h"

class MyNode {
public:
    MyNode(const std::string& config_file, const bool compressed);

    void img0_callback(const sensor_msgs::Image::ConstPtr &img_msg);
    void img0_compressed_callback(const sensor_msgs::CompressedImage::ConstPtr &img_msg);
    void odom_callback(const nav_msgs::Odometry::ConstPtr& msg);
    cv::Mat getImageFromMsg(const sensor_msgs::Image::ConstPtr &img_msg);
    cv::Mat getImageFromMsg(const sensor_msgs::CompressedImage::ConstPtr &img_msg);
    void on_3d_points_produced(const std::vector<Eigen::Vector3d>& points, double time);
    void sync_process();


private:
    template<typename T> 
    void getImageFromBuf(T& buf0, cv::Mat& image, std_msgs::Header& header, double& time) {
        if(!buf0.empty())
        {
            time = buf0.front()->header.stamp.toSec();
            header = buf0.front()->header;
            image = getImageFromMsg(buf0.front());
            buf0.pop();
        }
    }

    queue<sensor_msgs::Image::ConstPtr> img0_buf;
    queue<sensor_msgs::CompressedImage::ConstPtr> img0_buf_compressed;
    std::mutex m_buf;

    ros::NodeHandle nh_;
    ros::Subscriber sub_img0_;
    ros::Subscriber sub_odom_;

    ros::Publisher pub_points_;

    MyEstimator estimator_;
    const bool compressed_;
};

MyNode::MyNode(const std::string& config_file, const bool compressed): nh_("~"),estimator_(nh_),compressed_(compressed)
{
    readParameters(config_file);
    estimator_.setParameter();

    if (compressed_)
        sub_img0_ = nh_.subscribe(IMAGE0_TOPIC, 100, &MyNode::img0_compressed_callback, this);
    else
        sub_img0_ = nh_.subscribe(IMAGE0_TOPIC, 100, &MyNode::img0_callback, this);

    sub_odom_ = nh_.subscribe("/odom", 1000, &MyNode::odom_callback, this);

    //pub_points_ = nh_.advertise<sensor_msgs::PointCloud2>("/velodyne_points", 100);

    estimator_.setPointsCloudCallback(std::bind(&MyNode::on_3d_points_produced, this, std::placeholders::_1, std::placeholders::_2));
}


void MyNode::img0_callback(const sensor_msgs::Image::ConstPtr &img_msg)
{
    m_buf.lock();
    img0_buf.push(img_msg);
    m_buf.unlock();
}

void MyNode::img0_compressed_callback(const sensor_msgs::CompressedImage::ConstPtr &img_msg)
{
    m_buf.lock();
    img0_buf_compressed.push(img_msg);
    m_buf.unlock();
}

void MyNode::odom_callback(const nav_msgs::Odometry::ConstPtr& msg)
{
    auto t = msg->header.stamp.toSec();
    Eigen::Vector3d pose;
    pose.x() = msg->pose.pose.position.x;
    pose.y() = msg->pose.pose.position.y;

    Eigen::Quaterniond quat(msg->pose.pose.orientation.w, msg->pose.pose.orientation.x, 
                            msg->pose.pose.orientation.y,msg->pose.pose.orientation.z);

    pose.z() = RPYFromQuat(quat)[2];

    estimator_.inputOdometry(t, pose);
}

cv::Mat MyNode::getImageFromMsg(const sensor_msgs::Image::ConstPtr &img_msg)
{
    cv_bridge::CvImageConstPtr ptr;
    if (img_msg->encoding == "8UC1")
    {
        sensor_msgs::Image img;
        img.header = img_msg->header;
        img.height = img_msg->height;
        img.width = img_msg->width;
        img.is_bigendian = img_msg->is_bigendian;
        img.step = img_msg->step;
        img.data = img_msg->data;
        img.encoding = "mono8";
        ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);
    }
    else
        ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);

    cv::Mat img = ptr->image.clone();
    return img;
}

cv::Mat MyNode::getImageFromMsg(const sensor_msgs::CompressedImage::ConstPtr &img_msg)
{
    cv_bridge::CvImageConstPtr ptr;
    ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);
    cv::Mat img = ptr->image.clone();
    return img;
}

void MyNode::on_3d_points_produced(const std::vector<Eigen::Vector3d>& points, double time)
{
    sensor_msgs::PointCloud msg;
    sensor_msgs::PointCloud2 msg2;

    // convert point cloud generated by camera to make it looks like generated by velodyne lidar
    msg.header.frame_id = "velodyne";
    msg.header.stamp = ros::Time(time);

    Eigen::Matrix4d lidar_to_cam;
    lidar_to_cam << 0.03224607, -0.99945557, -0.00698191,  -0.03543017,
           -0.04428267,  0.00555003, -0.99900362, -0.23488971,
           0.99849849,  0.03252312, -0.04407959,  -0.65922496,
           0, 0, 0, 1;
    Eigen::Matrix4d cam_to_lidar = TransformInverse(lidar_to_cam);

    for (const auto& pt : points) {
        Eigen::Vector4d pt4;
        pt4.block(0,0,3,1) = pt.cast<double>();
        pt4(3) = 1;
        pt4 = cam_to_lidar * pt4;
        pt4 /= pt4(3);

        geometry_msgs::Point32 p;
        p.x = pt4(0);
        p.y = pt4(1);
        p.z = pt4(2);
        msg.points.push_back(p);
    }
    convertPointCloudToPointCloud2(msg, msg2);

    //pub_points_.publish(msg2);
    //std::cout << "pub points " << msg.points.size() << std::endl;
}

// extract images with same timestamp from two topics
void MyNode::sync_process()
{
    while(1)
    {
        cv::Mat image;
        std_msgs::Header header;
        double time = 0;
        
        m_buf.lock();
        if (compressed_)
            getImageFromBuf(img0_buf_compressed, image, header, time);
        else
            getImageFromBuf(img0_buf, image, header, time);
        m_buf.unlock();

        if(!image.empty()) {
            estimator_.inputImage(time, image);
        }

        std::chrono::milliseconds dura(2);
        std::this_thread::sleep_for(dura);
    }
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "vins_estimator");
    ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info);
    
    if(argc < 2)
    {
        printf("please intput: rosrun vins vins_node [config file] \n"
               "for example: rosrun vins vins_node "
               "~/catkin_ws/src/VINS-Fusion/config/euroc/euroc_stereo_imu_config.yaml \n");
        return 1;
    }

    string config_file = argv[1];
    printf("config_file: %s\n", argv[1]);

    bool compressed = false;
    if (argc > 2) {
        std::string compressed_str = argv[2];
        compressed = (compressed_str == "compressed");
    }

#ifdef EIGEN_DONT_PARALLELIZE
    ROS_DEBUG("EIGEN_DONT_PARALLELIZE");
#endif

    ROS_WARN("waiting for image and imu...");


    MyNode my_node(config_file, compressed);
    std::thread sync_thread(&MyNode::sync_process, &my_node);

    ros::spin();

    return 0;
}
