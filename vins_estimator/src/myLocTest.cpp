/*******************************************************
 * Author: Weizhe Liu
 * Date: 2019/3
 *******************************************************/

#include <stdio.h>
#include <queue>
#include <map>
#include <thread>
#include <mutex>
#include <ros/ros.h>
#include <nav_msgs/Odometry.h>
#include <sensor_msgs/PointCloud.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/point_cloud_conversion.h>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/opencv.hpp>
#include "estimator/my_estimator.h"
#include "my_transform.h"
#include "estimator/parameters.h"

#define IMAGE_COMPRESSED

#ifdef IMAGE_COMPRESSED
#include <sensor_msgs/CompressedImage.h>
#define MSG_IMAGE_TYPE sensor_msgs::CompressedImage
#else
#define MSG_IMAGE_TYPE sensor_msgs::Image
#endif

class MyNode {
public:
    MyNode(const std::string& config_file);

    void img0_callback(const MSG_IMAGE_TYPE::ConstPtr &img_msg);
    void odom_callback(const nav_msgs::Odometry::ConstPtr& msg);
    cv::Mat getImageFromMsg(const MSG_IMAGE_TYPE::ConstPtr &img_msg);
    void on_3d_points_produced(const std::vector<Eigen::Vector3d>& points, double time);
    void sync_process();



queue<MSG_IMAGE_TYPE::ConstPtr> img0_buf;
std::mutex m_buf;

private:
    ros::NodeHandle nh_;
    ros::Subscriber sub_img0_;
    ros::Subscriber sub_odom_;

    ros::Publisher pub_points_;

    MyEstimator estimator_;
};

MyNode::MyNode(const std::string& config_file): nh_("~"),estimator_(nh_)
{
    readParameters(config_file);
    estimator_.setParameter();

    sub_img0_ = nh_.subscribe(IMAGE0_TOPIC, 100, &MyNode::img0_callback, this);
    sub_odom_ = nh_.subscribe("/odom", 1000, &MyNode::odom_callback, this);

    pub_points_ = nh_.advertise<sensor_msgs::PointCloud2>("/velodyne_points", 100);

    estimator_.setPointsCloudCallback(std::bind(&MyNode::on_3d_points_produced, this, std::placeholders::_1, std::placeholders::_2));
}


void MyNode::img0_callback(const MSG_IMAGE_TYPE::ConstPtr &img_msg)
{
    m_buf.lock();
    img0_buf.push(img_msg);
    m_buf.unlock();
}

void MyNode::odom_callback(const nav_msgs::Odometry::ConstPtr& msg)
{
    auto t = msg->header.stamp.toSec();
    Eigen::Vector3d pose;
    pose.x() = msg->pose.pose.position.x;
    pose.y() = msg->pose.pose.position.y;

    Eigen::Quaterniond quat(msg->pose.pose.orientation.w, msg->pose.pose.orientation.x, 
                            msg->pose.pose.orientation.y,msg->pose.pose.orientation.z);

    pose.z() = RPYFromQuat(quat)[2];

    estimator_.inputOdometry(t, pose);
}

cv::Mat MyNode::getImageFromMsg(const MSG_IMAGE_TYPE::ConstPtr &img_msg)
{
    cv_bridge::CvImageConstPtr ptr;
#ifdef IMAGE_COMPRESSED
    ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);
#else
    if (img_msg->encoding == "8UC1")
    {
        MSG_IMAGE_TYPE img;
        img.header = img_msg->header;
        img.height = img_msg->height;
        img.width = img_msg->width;
        img.is_bigendian = img_msg->is_bigendian;
        img.step = img_msg->step;
        img.data = img_msg->data;
        img.encoding = "mono8";
        ptr = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::MONO8);
    }
    else
        ptr = cv_bridge::toCvCopy(img_msg, sensor_msgs::image_encodings::MONO8);
#endif
    cv::Mat img = ptr->image.clone();
    return img;
}

void MyNode::on_3d_points_produced(const std::vector<Eigen::Vector3d>& points, double time)
{
    sensor_msgs::PointCloud msg;
    sensor_msgs::PointCloud2 msg2;

    // convert point cloud generated by camera to make it looks like generated by velodyne lidar
    msg.header.frame_id = "velodyne";
    msg.header.stamp = ros::Time(time);

    Eigen::Matrix4d lidar_to_cam;
    lidar_to_cam << 0.03224607, -0.99945557, -0.00698191,  -0.03543017,
           -0.04428267,  0.00555003, -0.99900362, -0.23488971,
           0.99849849,  0.03252312, -0.04407959,  -0.65922496,
           0, 0, 0, 1;
    Eigen::Matrix4d cam_to_lidar = TransformInverse(lidar_to_cam);

    for (const auto& pt : points) {
        Eigen::Vector4d pt4;
        pt4.block(0,0,3,1) = pt.cast<double>();
        pt4(3) = 1;
        pt4 = cam_to_lidar * pt4;
        pt4 /= pt4(3);

        geometry_msgs::Point32 p;
        p.x = pt4(0);
        p.y = pt4(1);
        p.z = pt4(2);
        msg.points.push_back(p);
    }
    convertPointCloudToPointCloud2(msg, msg2);

    pub_points_.publish(msg2);
    //std::cout << "pub points " << msg.points.size() << std::endl;
}

// extract images with same timestamp from two topics
void MyNode::sync_process()
{
    while(1)
    {
        cv::Mat image;
        std_msgs::Header header;
        double time = 0;
        m_buf.lock();
        if(!img0_buf.empty())
        {
            time = img0_buf.front()->header.stamp.toSec();
            header = img0_buf.front()->header;
            image = getImageFromMsg(img0_buf.front());
            img0_buf.pop();
        }
        m_buf.unlock();
        if(!image.empty()) {
            estimator_.inputImage(time, image);
        }

        std::chrono::milliseconds dura(2);
        std::this_thread::sleep_for(dura);
    }
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "vins_estimator");
    ros::console::set_logger_level(ROSCONSOLE_DEFAULT_NAME, ros::console::levels::Info);
    
    if(argc != 2)
    {
        printf("please intput: rosrun vins vins_node [config file] \n"
               "for example: rosrun vins vins_node "
               "~/catkin_ws/src/VINS-Fusion/config/euroc/euroc_stereo_imu_config.yaml \n");
        return 1;
    }

    string config_file = argv[1];
    printf("config_file: %s\n", argv[1]);

    
#ifdef EIGEN_DONT_PARALLELIZE
    ROS_DEBUG("EIGEN_DONT_PARALLELIZE");
#endif

    ROS_WARN("waiting for image and imu...");


    MyNode my_node(config_file);
    std::thread sync_thread(&MyNode::sync_process, &my_node);

    ros::spin();

    return 0;
}
